<?php

namespace App\Controllers;

use DI\Container;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ServerRequestInterface;
use Illuminate\Database\Capsule\Manager as DB;

class EntryType
{
  private $container;
  private $loadedModels;

  public function __construct(Container $container)
  {
    $this->container = $container;
    $this->loadedModels = $container->get('sysinfo')['loadedModels'];
  }

  /**
   * Checks if model is loaded/exists and returns the real, usable model name
   */
  private function getModelFromArg(string $modelName)
  {
    $modelIndex = array_search(
      strtolower($modelName),
      // filter out those files we wanted to opt out
      array_filter(
        // format all model names to be all in lowercase
        array_map(function ($modelName) {
          return strtolower($modelName);
        }, $this->loadedModels),
        function ($modelName) {
          return !in_array($modelName, ['files']);
        },
      ),
    );
    if ($modelIndex === false) {
      return false;
    }

    $modelName = $this->loadedModels[$modelIndex];

    return "\\$modelName";
  }

  public function getInfo(
    ServerRequestInterface $request,
    ResponseInterface $response,
    array $args
  ): ResponseInterface {
    $modelInstancePath = $this->getModelFromArg($args['modelId']);
    if ($modelInstancePath === false) {
      return $response->withStatus(404);
    }

    $classInstance = new $modelInstancePath();

    $response->getBody()->write(
      json_encode([
        'data' => $classInstance->getSummary(),
      ]),
    );

    return $response;
  }

  public function reorderEntries(
    ServerRequestInterface $request,
    ResponseInterface $response,
    array $args
  ): ResponseInterface {
    $modelInstancePath = $this->getModelFromArg($args['modelId']);
    $classInstance = new $modelInstancePath();
    $parsedBody = $request->getParsedBody();
    $data = $parsedBody['data'];

    if (
      !$classInstance->getSummary()->hasOrdering ||
      !isset($data['fromId']) ||
      !isset($data['toId'])
    ) {
      return $response->withStatus(400);
    }

    try {
      $fromEntry = $modelInstancePath
        ::where('id', $data['fromId'])
        ->get()
        ->firstOrFail();
      $toEntry = $modelInstancePath
        ::where('id', $data['toId'])
        ->get()
        ->firstOrFail();

      DB::beginTransaction();

      $savedOrderId = $toEntry->order;
      $toEntry->order = $fromEntry->order;
      $fromEntry->order = $savedOrderId;

      $fromEntry->save();
      $toEntry->save();

      DB::commit();

      $response->getBody()->write(
        json_encode([
          'data' => 1,
        ]),
      );
    } catch (\Exception $e) {
      echo $e->getMessage();

      DB::rollback();

      return $response
        ->withStatus(500)
        ->withHeader('Content-Description', $e->getMessage());
    }

    return $response;
  }

  public function getManyEntries(
    ServerRequestInterface $request,
    ResponseInterface $response,
    array $args
  ): ResponseInterface {
    $modelInstancePath = $this->getModelFromArg($args['modelId']);
    if ($modelInstancePath === false) {
      return $response->withStatus(404);
    }

    $queryParams = $request->getQueryParams();
    $page = isset($queryParams['page']) ? $queryParams['page'] : 0;
    $classInstance = new $modelInstancePath();

    if ($classInstance->getSummary()->hasOrdering) {
      $query = $modelInstancePath
        ::orderBy('order', 'ASC')
        ->orderBy('id', 'ASC');
    } else {
      $query = $modelInstancePath::orderBy('id', 'ASC');
    }

    $dataPaginated = json_decode(
      $query->paginate(15, ['*'], 'page', $page)->toJson(),
    );
    // Unset some things as they are not useful or active
    unset($dataPaginated->links);
    unset($dataPaginated->first_page_url);
    unset($dataPaginated->last_page_url);
    unset($dataPaginated->next_page_url);
    unset($dataPaginated->prev_page_url);
    unset($dataPaginated->path);

    $response->getBody()->write(json_encode($dataPaginated));

    return $response;
  }

  public function updateEntry(
    ServerRequestInterface $request,
    ResponseInterface $response,
    array $args
  ): ResponseInterface {
    $modelInstancePath = $this->getModelFromArg($args['modelId']);
    if ($modelInstancePath === false) {
      return $response->withStatus(404);
    }

    $parsedBody = $request->getParsedBody();

    try {
      $response->getBody()->write(
        json_encode([
          'data' => $modelInstancePath
            ::find($args['itemId'])
            ->update($parsedBody['data']),
        ]),
      );
    } catch (\Exception $ex) {
      if ($ex->getCode() === '23000') {
        $errorText = str_replace(
          ['UNIQUE constraint failed: ', ' '],
          '',
          $ex->errorInfo[2],
        );
        $response->getBody()->write(
          json_encode([
            'data' => array_map(function ($item) {
              return explode('.', $item)[1];
            }, explode(',', $errorText)),
            'code' => intval($ex->getCode()),
            'message' => 'Duplicate entries',
          ]),
        );

        return $response
          ->withStatus(400)
          ->withHeader('Content-Description', $ex->getMessage());
      } else {
        return $response
          ->withStatus(500)
          ->withHeader('Content-Description', $ex->getMessage());
      }
    }
  }

  public function getEntry(
    ServerRequestInterface $request,
    ResponseInterface $response,
    array $args
  ): ResponseInterface {
    $modelInstancePath = $this->getModelFromArg($args['modelId']);
    if ($modelInstancePath === false) {
      return $response->withStatus(404);
    }

    try {
      $response->getBody()->write(
        json_encode([
          'data' => $modelInstancePath
            ::where('id', $args['itemId'])
            ->get()
            ->firstOrFail(),
        ]),
      );

      return $response;
    } catch (\Exception $e) {
      return $response->withStatus(404);
    }
  }

  public function createEntry(
    ServerRequestInterface $request,
    ResponseInterface $response,
    array $args
  ): ResponseInterface {
    $modelInstancePath = $this->getModelFromArg($args['modelId']);
    if ($modelInstancePath === false) {
      return $response->withStatus(404);
    }

    $parsedBody = $request->getParsedBody();

    try {
      $response->getBody()->write(
        json_encode([
          'data' => $modelInstancePath::create($parsedBody['data']),
        ]),
      );

      return $response;
    } catch (\Exception $ex) {
      if ($ex->getCode() === '23000') {
        $errorText = str_replace(
          ['UNIQUE constraint failed: ', ' '],
          '',
          $ex->errorInfo[2],
        );
        $response->getBody()->write(
          json_encode([
            'data' => array_map(function ($item) {
              return explode('.', $item)[1];
            }, explode(',', $errorText)),
            'code' => intval($ex->getCode()),
            'message' => 'Duplicate entries',
          ]),
        );

        return $response
          ->withStatus(400)
          ->withHeader('Content-Description', $ex->getMessage());
      } else {
        return $response
          ->withStatus(500)
          ->withHeader('Content-Description', $ex->getMessage());
      }
    }
  }

  public function deleteEntry(
    ServerRequestInterface $request,
    ResponseInterface $response,
    array $args
  ): ResponseInterface {
    $modelInstancePath = $this->getModelFromArg($args['modelId']);
    if ($modelInstancePath === false) {
      return $response->withStatus(404);
    }

    $response->getBody()->write(
      json_encode([
        'data' => $modelInstancePath::where('id', $args['itemId'])->delete(),
      ]),
    );

    return $response;
  }
}
