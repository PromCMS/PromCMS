<?php

namespace App\Controllers;

use App\Exceptions\EntityDuplicateException;
use DI\Container;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ServerRequestInterface;

class EntryType
{
  private $currentUser;

  public function __construct(Container $container)
  {
    $this->currentUser = $container->get('session')->get('user', false);
  }

  public function getInfo(
    ServerRequestInterface $request,
    ResponseInterface $response
  ): ResponseInterface {
    $instance = $request->getAttribute('model-instance');

    prepareJsonResponse($response, $instance->getSummary());

    return $response;
  }

  public function swapTwo(
    ServerRequestInterface $request,
    ResponseInterface $response
  ): ResponseInterface {
    $classInstance = $request->getAttribute('model-instance');
    $instance = $request->getAttribute('model-instance');
    $parsedBody = $request->getParsedBody();
    $data = $parsedBody['data'];

    if (
      !$instance->getSummary()->hasOrdering ||
      !isset($data['fromId']) ||
      !isset($data['toId']) ||
      $data['fromId'] === $data['toId']
    ) {
      return $response->withStatus(400);
    }

    // TODO: add transactions
    try {
      $ownableQueryFilter =
        $request->getAttribute('permission-only-own', false) === true
          ? onlyOwnersOrEditors($this->currentUser->id, $classInstance)
          : [];

      $fromEntry = $classInstance
        ->where(
          array_merge(
            ['id', '=', intval($data['fromId'])],
            $ownableQueryFilter,
          ),
        )
        ->getOne();

      $toEntry = $classInstance
        ->where(
          array_merge(['id', '=', intval($data['toId'])], $ownableQueryFilter),
        )
        ->getOne();

      // just make copy of data with just 'order' values which we will be saving to db
      $fromEntryData = ['order' => $fromEntry->order];
      $toEntryData = ['order' => $toEntry->order];

      $savedOrderId = $toEntryData['order'];
      $toEntryData['order'] = $fromEntryData['order'];
      $fromEntryData['order'] = $savedOrderId;

      if ($instance->getSummary()->ownable && $this->currentUser) {
        $fromEntryData['updated_by'] = $this->currentUser->id;
        $toEntryData['updated_by'] = $this->currentUser->id;
      }

      $fromEntry->update($fromEntryData);
      $toEntry->update($toEntryData);

      prepareJsonResponse($response, [], '', 'success');
    } catch (\Exception $e) {
      return $response
        ->withStatus(500)
        ->withHeader('x-custom-message', $e->getMessage())
        ->withHeader('x-custom-trace', $e->getTraceAsString());
    }

    return $response;
  }

  public function getMany(
    ServerRequestInterface $request,
    ResponseInterface $response
  ): ResponseInterface {
    $classInstance = $request->getAttribute('model-instance');
    $queryParams = $request->getQueryParams();
    $page = isset($queryParams['page']) ? $queryParams['page'] : 0;

    $pageLimit = 15;
    $query = $classInstance
      ->orderBy(
        $classInstance->getSummary()->hasOrdering
          ? ['order' => 'asc', 'id' => 'asc']
          : ['id' => 'asc'],
      )
      ->limit($pageLimit)
      ->skip($pageLimit * $page);

    if ($request->getAttribute('permission-only-own', false) === true) {
      $filter = onlyOwnersOrEditors($this->currentUser->id, $classInstance);
      $total = count($classInstance->where($filter)->getMany());
      $query->where($filter);
    } else {
      $total = count($classInstance->getMany());
    }

    $data = $query->getMany();

    $response->getBody()->write(
      json_encode([
        'data' => $data,
        'current_page' => $page,
        'last_page' => floor($total / $pageLimit),
        'per_page' => $pageLimit,
        'total' => $total,
        'from' => $pageLimit * $page + 1,
        'to' => $pageLimit * $page + $pageLimit,
      ]),
    );

    return $response;
  }

  public function update(
    ServerRequestInterface $request,
    ResponseInterface $response,
    array $args
  ): ResponseInterface {
    $classInstance = $request->getAttribute('model-instance');
    $parsedBody = $request->getParsedBody();

    try {
      $query = $classInstance;

      if ($request->getAttribute('permission-only-own', false) === true) {
        $query->where(
          onlyOwnersOrEditors($this->currentUser->id, $classInstance),
        );
      }

      $item = $query->getById($args['itemId']);

      if ($classInstance->getSummary()->ownable && $this->currentUser) {
        $parsedBody['data']['updated_by'] = $this->currentUser->id;
      }

      $item->update($parsedBody['data']);

      prepareJsonResponse($response, $item->getData());

      return $response;
    } catch (\Exception $ex) {
      if ($ex instanceof EntityDuplicateException) {
        handleDuplicateEntriesError($response, $ex);

        return $response
          ->withStatus(400)
          ->withHeader('Content-Description', $ex->getMessage());
      } else {
        return $response
          ->withStatus(500)
          ->withHeader('Content-Description', $ex->getMessage());
      }
    }
  }

  public function getOne(
    ServerRequestInterface $request,
    ResponseInterface $response,
    array $args
  ): ResponseInterface {
    $classInstance = $request->getAttribute('model-instance');

    try {
      $query = $classInstance->where(['id', '=', intval($args['itemId'])]);

      if ($request->getAttribute('permission-only-own', false) === true) {
        $query->where(
          onlyOwnersOrEditors($this->currentUser->id, $classInstance),
        );
      }

      $item = $query->getOne();

      prepareJsonResponse($response, $item->getData());

      return $response;
    } catch (\Exception $error) {
      return $response
        ->withStatus(404)
        ->withHeader('Content-Description', $error->getMessage());
    }
  }

  public function create(
    ServerRequestInterface $request,
    ResponseInterface $response
  ): ResponseInterface {
    $classInstance = $request->getAttribute('model-instance');
    $parsedBody = $request->getParsedBody();

    try {
      if ($classInstance->getSummary()->ownable && $this->currentUser) {
        $parsedBody['data']['created_by'] = $this->currentUser->id;
      }

      prepareJsonResponse(
        $response,
        $classInstance->create($parsedBody['data'])->getData(),
      );

      return $response;
    } catch (\Exception $ex) {
      if ($ex instanceof EntityDuplicateException) {
        handleDuplicateEntriesError($response, $ex);

        return $response
          ->withStatus(400)
          ->withHeader('Content-Description', $ex->getMessage());
      } else {
        return $response
          ->withStatus(500)
          ->withHeader('Content-Description', $ex->getMessage());
      }
    }
  }

  public function delete(
    ServerRequestInterface $request,
    ResponseInterface $response,
    array $args
  ): ResponseInterface {
    $classInstance = $request->getAttribute('model-instance');

    $query = $classInstance->where(['id', '=', intval($args['itemId'])]);

    if ($request->getAttribute('permission-only-own', false) === true) {
      $query->where(
        onlyOwnersOrEditors($this->currentUser->id, $classInstance),
      );
    }

    if (!$query->delete()) {
      prepareJsonResponse($response, [], 'Failed to delete');

      return $response
        ->withStatus(500)
        ->withHeader('Content-Description', 'Failed to delete');
    }

    prepareJsonResponse($response, [], 'Item deleted');

    return $response;
  }
}
